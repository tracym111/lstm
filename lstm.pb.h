// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lstm.proto

#ifndef PROTOBUF_lstm_2eproto__INCLUDED
#define PROTOBUF_lstm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "job.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_lstm_2eproto();
void protobuf_AssignDesc_lstm_2eproto();
void protobuf_ShutdownFile_lstm_2eproto();

class EmbeddingProto;
class LossProto;
class DataProto;
class UnrollProto;
class HiddenProto;
class WordRecord;

// ===================================================================

class EmbeddingProto : public ::google::protobuf::Message {
 public:
  EmbeddingProto();
  virtual ~EmbeddingProto();

  EmbeddingProto(const EmbeddingProto& from);

  inline EmbeddingProto& operator=(const EmbeddingProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmbeddingProto& default_instance();

  void Swap(EmbeddingProto* other);

  // implements Message ----------------------------------------------

  EmbeddingProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmbeddingProto& from);
  void MergeFrom(const EmbeddingProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 word_dim = 1;
  inline bool has_word_dim() const;
  inline void clear_word_dim();
  static const int kWordDimFieldNumber = 1;
  inline ::google::protobuf::int32 word_dim() const;
  inline void set_word_dim(::google::protobuf::int32 value);

  // optional int32 vocab_size = 2;
  inline bool has_vocab_size() const;
  inline void clear_vocab_size();
  static const int kVocabSizeFieldNumber = 2;
  inline ::google::protobuf::int32 vocab_size() const;
  inline void set_vocab_size(::google::protobuf::int32 value);

  // optional int32 batch_size = 3;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 3;
  inline ::google::protobuf::int32 batch_size() const;
  inline void set_batch_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:EmbeddingProto)
 private:
  inline void set_has_word_dim();
  inline void clear_has_word_dim();
  inline void set_has_vocab_size();
  inline void clear_has_vocab_size();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 word_dim_;
  ::google::protobuf::int32 vocab_size_;
  ::google::protobuf::int32 batch_size_;
  friend void  protobuf_AddDesc_lstm_2eproto();
  friend void protobuf_AssignDesc_lstm_2eproto();
  friend void protobuf_ShutdownFile_lstm_2eproto();

  void InitAsDefaultInstance();
  static EmbeddingProto* default_instance_;
};
// -------------------------------------------------------------------

class LossProto : public ::google::protobuf::Message {
 public:
  LossProto();
  virtual ~LossProto();

  LossProto(const LossProto& from);

  inline LossProto& operator=(const LossProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LossProto& default_instance();

  void Swap(LossProto* other);

  // implements Message ----------------------------------------------

  LossProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LossProto& from);
  void MergeFrom(const LossProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 nclass = 1;
  inline bool has_nclass() const;
  inline void clear_nclass();
  static const int kNclassFieldNumber = 1;
  inline ::google::protobuf::int32 nclass() const;
  inline void set_nclass(::google::protobuf::int32 value);

  // optional int32 vocab_size = 2;
  inline bool has_vocab_size() const;
  inline void clear_vocab_size();
  static const int kVocabSizeFieldNumber = 2;
  inline ::google::protobuf::int32 vocab_size() const;
  inline void set_vocab_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LossProto)
 private:
  inline void set_has_nclass();
  inline void clear_has_nclass();
  inline void set_has_vocab_size();
  inline void clear_has_vocab_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 nclass_;
  ::google::protobuf::int32 vocab_size_;
  friend void  protobuf_AddDesc_lstm_2eproto();
  friend void protobuf_AssignDesc_lstm_2eproto();
  friend void protobuf_ShutdownFile_lstm_2eproto();

  void InitAsDefaultInstance();
  static LossProto* default_instance_;
};
// -------------------------------------------------------------------

class DataProto : public ::google::protobuf::Message {
 public:
  DataProto();
  virtual ~DataProto();

  DataProto(const DataProto& from);

  inline DataProto& operator=(const DataProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataProto& default_instance();

  void Swap(DataProto* other);

  // implements Message ----------------------------------------------

  DataProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataProto& from);
  void MergeFrom(const DataProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional int32 max_window = 2;
  inline bool has_max_window() const;
  inline void clear_max_window();
  static const int kMaxWindowFieldNumber = 2;
  inline ::google::protobuf::int32 max_window() const;
  inline void set_max_window(::google::protobuf::int32 value);

  // optional string backend = 3 [default = "kvfile"];
  inline bool has_backend() const;
  inline void clear_backend();
  static const int kBackendFieldNumber = 3;
  inline const ::std::string& backend() const;
  inline void set_backend(const ::std::string& value);
  inline void set_backend(const char* value);
  inline void set_backend(const char* value, size_t size);
  inline ::std::string* mutable_backend();
  inline ::std::string* release_backend();
  inline void set_allocated_backend(::std::string* backend);

  // optional int32 batch_size = 4;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 4;
  inline ::google::protobuf::int32 batch_size() const;
  inline void set_batch_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DataProto)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_max_window();
  inline void clear_has_max_window();
  inline void set_has_backend();
  inline void clear_has_backend();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  static ::std::string* _default_backend_;
  ::std::string* backend_;
  ::google::protobuf::int32 max_window_;
  ::google::protobuf::int32 batch_size_;
  friend void  protobuf_AddDesc_lstm_2eproto();
  friend void protobuf_AssignDesc_lstm_2eproto();
  friend void protobuf_ShutdownFile_lstm_2eproto();

  void InitAsDefaultInstance();
  static DataProto* default_instance_;
};
// -------------------------------------------------------------------

class UnrollProto : public ::google::protobuf::Message {
 public:
  UnrollProto();
  virtual ~UnrollProto();

  UnrollProto(const UnrollProto& from);

  inline UnrollProto& operator=(const UnrollProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnrollProto& default_instance();

  void Swap(UnrollProto* other);

  // implements Message ----------------------------------------------

  UnrollProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnrollProto& from);
  void MergeFrom(const UnrollProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 batch_size = 1;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 1;
  inline ::google::protobuf::int32 batch_size() const;
  inline void set_batch_size(::google::protobuf::int32 value);

  // optional int32 max_window = 2;
  inline bool has_max_window() const;
  inline void clear_max_window();
  static const int kMaxWindowFieldNumber = 2;
  inline ::google::protobuf::int32 max_window() const;
  inline void set_max_window(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UnrollProto)
 private:
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_max_window();
  inline void clear_has_max_window();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 batch_size_;
  ::google::protobuf::int32 max_window_;
  friend void  protobuf_AddDesc_lstm_2eproto();
  friend void protobuf_AssignDesc_lstm_2eproto();
  friend void protobuf_ShutdownFile_lstm_2eproto();

  void InitAsDefaultInstance();
  static UnrollProto* default_instance_;
};
// -------------------------------------------------------------------

class HiddenProto : public ::google::protobuf::Message {
 public:
  HiddenProto();
  virtual ~HiddenProto();

  HiddenProto(const HiddenProto& from);

  inline HiddenProto& operator=(const HiddenProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HiddenProto& default_instance();

  void Swap(HiddenProto* other);

  // implements Message ----------------------------------------------

  HiddenProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HiddenProto& from);
  void MergeFrom(const HiddenProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 word_dim = 1;
  inline bool has_word_dim() const;
  inline void clear_word_dim();
  static const int kWordDimFieldNumber = 1;
  inline ::google::protobuf::int32 word_dim() const;
  inline void set_word_dim(::google::protobuf::int32 value);

  // optional int32 batch_size = 2;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 2;
  inline ::google::protobuf::int32 batch_size() const;
  inline void set_batch_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:HiddenProto)
 private:
  inline void set_has_word_dim();
  inline void clear_has_word_dim();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 word_dim_;
  ::google::protobuf::int32 batch_size_;
  friend void  protobuf_AddDesc_lstm_2eproto();
  friend void protobuf_AssignDesc_lstm_2eproto();
  friend void protobuf_ShutdownFile_lstm_2eproto();

  void InitAsDefaultInstance();
  static HiddenProto* default_instance_;
};
// -------------------------------------------------------------------

class WordRecord : public ::google::protobuf::Message {
 public:
  WordRecord();
  virtual ~WordRecord();

  WordRecord(const WordRecord& from);

  inline WordRecord& operator=(const WordRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordRecord& default_instance();

  void Swap(WordRecord* other);

  // implements Message ----------------------------------------------

  WordRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WordRecord& from);
  void MergeFrom(const WordRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string word = 1;
  inline bool has_word() const;
  inline void clear_word();
  static const int kWordFieldNumber = 1;
  inline const ::std::string& word() const;
  inline void set_word(const ::std::string& value);
  inline void set_word(const char* value);
  inline void set_word(const char* value, size_t size);
  inline ::std::string* mutable_word();
  inline ::std::string* release_word();
  inline void set_allocated_word(::std::string* word);

  // optional int32 word_index = 2;
  inline bool has_word_index() const;
  inline void clear_word_index();
  static const int kWordIndexFieldNumber = 2;
  inline ::google::protobuf::int32 word_index() const;
  inline void set_word_index(::google::protobuf::int32 value);

  // optional int32 class_index = 3;
  inline bool has_class_index() const;
  inline void clear_class_index();
  static const int kClassIndexFieldNumber = 3;
  inline ::google::protobuf::int32 class_index() const;
  inline void set_class_index(::google::protobuf::int32 value);

  // optional int32 class_start = 4;
  inline bool has_class_start() const;
  inline void clear_class_start();
  static const int kClassStartFieldNumber = 4;
  inline ::google::protobuf::int32 class_start() const;
  inline void set_class_start(::google::protobuf::int32 value);

  // optional int32 class_end = 5;
  inline bool has_class_end() const;
  inline void clear_class_end();
  static const int kClassEndFieldNumber = 5;
  inline ::google::protobuf::int32 class_end() const;
  inline void set_class_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WordRecord)
 private:
  inline void set_has_word();
  inline void clear_has_word();
  inline void set_has_word_index();
  inline void clear_has_word_index();
  inline void set_has_class_index();
  inline void clear_has_class_index();
  inline void set_has_class_start();
  inline void clear_has_class_start();
  inline void set_has_class_end();
  inline void clear_has_class_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* word_;
  ::google::protobuf::int32 word_index_;
  ::google::protobuf::int32 class_index_;
  ::google::protobuf::int32 class_start_;
  ::google::protobuf::int32 class_end_;
  friend void  protobuf_AddDesc_lstm_2eproto();
  friend void protobuf_AssignDesc_lstm_2eproto();
  friend void protobuf_ShutdownFile_lstm_2eproto();

  void InitAsDefaultInstance();
  static WordRecord* default_instance_;
};
// ===================================================================

static const int kEmbeddingConfFieldNumber = 101;
extern ::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::EmbeddingProto >, 11, false >
  embedding_conf;
static const int kLossConfFieldNumber = 102;
extern ::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::LossProto >, 11, false >
  loss_conf;
static const int kDataConfFieldNumber = 103;
extern ::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::DataProto >, 11, false >
  data_conf;
static const int kUnrollConfFieldNumber = 104;
extern ::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::UnrollProto >, 11, false >
  unroll_conf;
static const int kHidConfFieldNumber = 105;
extern ::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::HiddenProto >, 11, false >
  hid_conf;

// ===================================================================

// EmbeddingProto

// optional int32 word_dim = 1;
inline bool EmbeddingProto::has_word_dim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmbeddingProto::set_has_word_dim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmbeddingProto::clear_has_word_dim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmbeddingProto::clear_word_dim() {
  word_dim_ = 0;
  clear_has_word_dim();
}
inline ::google::protobuf::int32 EmbeddingProto::word_dim() const {
  // @@protoc_insertion_point(field_get:EmbeddingProto.word_dim)
  return word_dim_;
}
inline void EmbeddingProto::set_word_dim(::google::protobuf::int32 value) {
  set_has_word_dim();
  word_dim_ = value;
  // @@protoc_insertion_point(field_set:EmbeddingProto.word_dim)
}

// optional int32 vocab_size = 2;
inline bool EmbeddingProto::has_vocab_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmbeddingProto::set_has_vocab_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmbeddingProto::clear_has_vocab_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmbeddingProto::clear_vocab_size() {
  vocab_size_ = 0;
  clear_has_vocab_size();
}
inline ::google::protobuf::int32 EmbeddingProto::vocab_size() const {
  // @@protoc_insertion_point(field_get:EmbeddingProto.vocab_size)
  return vocab_size_;
}
inline void EmbeddingProto::set_vocab_size(::google::protobuf::int32 value) {
  set_has_vocab_size();
  vocab_size_ = value;
  // @@protoc_insertion_point(field_set:EmbeddingProto.vocab_size)
}

// optional int32 batch_size = 3;
inline bool EmbeddingProto::has_batch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmbeddingProto::set_has_batch_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmbeddingProto::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmbeddingProto::clear_batch_size() {
  batch_size_ = 0;
  clear_has_batch_size();
}
inline ::google::protobuf::int32 EmbeddingProto::batch_size() const {
  // @@protoc_insertion_point(field_get:EmbeddingProto.batch_size)
  return batch_size_;
}
inline void EmbeddingProto::set_batch_size(::google::protobuf::int32 value) {
  set_has_batch_size();
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:EmbeddingProto.batch_size)
}

// -------------------------------------------------------------------

// LossProto

// optional int32 nclass = 1;
inline bool LossProto::has_nclass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LossProto::set_has_nclass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LossProto::clear_has_nclass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LossProto::clear_nclass() {
  nclass_ = 0;
  clear_has_nclass();
}
inline ::google::protobuf::int32 LossProto::nclass() const {
  // @@protoc_insertion_point(field_get:LossProto.nclass)
  return nclass_;
}
inline void LossProto::set_nclass(::google::protobuf::int32 value) {
  set_has_nclass();
  nclass_ = value;
  // @@protoc_insertion_point(field_set:LossProto.nclass)
}

// optional int32 vocab_size = 2;
inline bool LossProto::has_vocab_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LossProto::set_has_vocab_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LossProto::clear_has_vocab_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LossProto::clear_vocab_size() {
  vocab_size_ = 0;
  clear_has_vocab_size();
}
inline ::google::protobuf::int32 LossProto::vocab_size() const {
  // @@protoc_insertion_point(field_get:LossProto.vocab_size)
  return vocab_size_;
}
inline void LossProto::set_vocab_size(::google::protobuf::int32 value) {
  set_has_vocab_size();
  vocab_size_ = value;
  // @@protoc_insertion_point(field_set:LossProto.vocab_size)
}

// -------------------------------------------------------------------

// DataProto

// required string path = 1;
inline bool DataProto::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataProto::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataProto::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataProto::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& DataProto::path() const {
  // @@protoc_insertion_point(field_get:DataProto.path)
  return *path_;
}
inline void DataProto::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:DataProto.path)
}
inline void DataProto::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataProto.path)
}
inline void DataProto::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataProto.path)
}
inline ::std::string* DataProto::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DataProto.path)
  return path_;
}
inline ::std::string* DataProto::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DataProto::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DataProto.path)
}

// optional int32 max_window = 2;
inline bool DataProto::has_max_window() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataProto::set_has_max_window() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataProto::clear_has_max_window() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataProto::clear_max_window() {
  max_window_ = 0;
  clear_has_max_window();
}
inline ::google::protobuf::int32 DataProto::max_window() const {
  // @@protoc_insertion_point(field_get:DataProto.max_window)
  return max_window_;
}
inline void DataProto::set_max_window(::google::protobuf::int32 value) {
  set_has_max_window();
  max_window_ = value;
  // @@protoc_insertion_point(field_set:DataProto.max_window)
}

// optional string backend = 3 [default = "kvfile"];
inline bool DataProto::has_backend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataProto::set_has_backend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataProto::clear_has_backend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataProto::clear_backend() {
  if (backend_ != _default_backend_) {
    backend_->assign(*_default_backend_);
  }
  clear_has_backend();
}
inline const ::std::string& DataProto::backend() const {
  // @@protoc_insertion_point(field_get:DataProto.backend)
  return *backend_;
}
inline void DataProto::set_backend(const ::std::string& value) {
  set_has_backend();
  if (backend_ == _default_backend_) {
    backend_ = new ::std::string;
  }
  backend_->assign(value);
  // @@protoc_insertion_point(field_set:DataProto.backend)
}
inline void DataProto::set_backend(const char* value) {
  set_has_backend();
  if (backend_ == _default_backend_) {
    backend_ = new ::std::string;
  }
  backend_->assign(value);
  // @@protoc_insertion_point(field_set_char:DataProto.backend)
}
inline void DataProto::set_backend(const char* value, size_t size) {
  set_has_backend();
  if (backend_ == _default_backend_) {
    backend_ = new ::std::string;
  }
  backend_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DataProto.backend)
}
inline ::std::string* DataProto::mutable_backend() {
  set_has_backend();
  if (backend_ == _default_backend_) {
    backend_ = new ::std::string(*_default_backend_);
  }
  // @@protoc_insertion_point(field_mutable:DataProto.backend)
  return backend_;
}
inline ::std::string* DataProto::release_backend() {
  clear_has_backend();
  if (backend_ == _default_backend_) {
    return NULL;
  } else {
    ::std::string* temp = backend_;
    backend_ = const_cast< ::std::string*>(_default_backend_);
    return temp;
  }
}
inline void DataProto::set_allocated_backend(::std::string* backend) {
  if (backend_ != _default_backend_) {
    delete backend_;
  }
  if (backend) {
    set_has_backend();
    backend_ = backend;
  } else {
    clear_has_backend();
    backend_ = const_cast< ::std::string*>(_default_backend_);
  }
  // @@protoc_insertion_point(field_set_allocated:DataProto.backend)
}

// optional int32 batch_size = 4;
inline bool DataProto::has_batch_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataProto::set_has_batch_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataProto::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataProto::clear_batch_size() {
  batch_size_ = 0;
  clear_has_batch_size();
}
inline ::google::protobuf::int32 DataProto::batch_size() const {
  // @@protoc_insertion_point(field_get:DataProto.batch_size)
  return batch_size_;
}
inline void DataProto::set_batch_size(::google::protobuf::int32 value) {
  set_has_batch_size();
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:DataProto.batch_size)
}

// -------------------------------------------------------------------

// UnrollProto

// optional int32 batch_size = 1;
inline bool UnrollProto::has_batch_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnrollProto::set_has_batch_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnrollProto::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnrollProto::clear_batch_size() {
  batch_size_ = 0;
  clear_has_batch_size();
}
inline ::google::protobuf::int32 UnrollProto::batch_size() const {
  // @@protoc_insertion_point(field_get:UnrollProto.batch_size)
  return batch_size_;
}
inline void UnrollProto::set_batch_size(::google::protobuf::int32 value) {
  set_has_batch_size();
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:UnrollProto.batch_size)
}

// optional int32 max_window = 2;
inline bool UnrollProto::has_max_window() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnrollProto::set_has_max_window() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnrollProto::clear_has_max_window() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnrollProto::clear_max_window() {
  max_window_ = 0;
  clear_has_max_window();
}
inline ::google::protobuf::int32 UnrollProto::max_window() const {
  // @@protoc_insertion_point(field_get:UnrollProto.max_window)
  return max_window_;
}
inline void UnrollProto::set_max_window(::google::protobuf::int32 value) {
  set_has_max_window();
  max_window_ = value;
  // @@protoc_insertion_point(field_set:UnrollProto.max_window)
}

// -------------------------------------------------------------------

// HiddenProto

// optional int32 word_dim = 1;
inline bool HiddenProto::has_word_dim() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HiddenProto::set_has_word_dim() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HiddenProto::clear_has_word_dim() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HiddenProto::clear_word_dim() {
  word_dim_ = 0;
  clear_has_word_dim();
}
inline ::google::protobuf::int32 HiddenProto::word_dim() const {
  // @@protoc_insertion_point(field_get:HiddenProto.word_dim)
  return word_dim_;
}
inline void HiddenProto::set_word_dim(::google::protobuf::int32 value) {
  set_has_word_dim();
  word_dim_ = value;
  // @@protoc_insertion_point(field_set:HiddenProto.word_dim)
}

// optional int32 batch_size = 2;
inline bool HiddenProto::has_batch_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HiddenProto::set_has_batch_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HiddenProto::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HiddenProto::clear_batch_size() {
  batch_size_ = 0;
  clear_has_batch_size();
}
inline ::google::protobuf::int32 HiddenProto::batch_size() const {
  // @@protoc_insertion_point(field_get:HiddenProto.batch_size)
  return batch_size_;
}
inline void HiddenProto::set_batch_size(::google::protobuf::int32 value) {
  set_has_batch_size();
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:HiddenProto.batch_size)
}

// -------------------------------------------------------------------

// WordRecord

// optional string word = 1;
inline bool WordRecord::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WordRecord::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WordRecord::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WordRecord::clear_word() {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_->clear();
  }
  clear_has_word();
}
inline const ::std::string& WordRecord::word() const {
  // @@protoc_insertion_point(field_get:WordRecord.word)
  return *word_;
}
inline void WordRecord::set_word(const ::std::string& value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set:WordRecord.word)
}
inline void WordRecord::set_word(const char* value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(value);
  // @@protoc_insertion_point(field_set_char:WordRecord.word)
}
inline void WordRecord::set_word(const char* value, size_t size) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  word_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WordRecord.word)
}
inline ::std::string* WordRecord::mutable_word() {
  set_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    word_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:WordRecord.word)
  return word_;
}
inline ::std::string* WordRecord::release_word() {
  clear_has_word();
  if (word_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = word_;
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WordRecord::set_allocated_word(::std::string* word) {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete word_;
  }
  if (word) {
    set_has_word();
    word_ = word;
  } else {
    clear_has_word();
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:WordRecord.word)
}

// optional int32 word_index = 2;
inline bool WordRecord::has_word_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WordRecord::set_has_word_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WordRecord::clear_has_word_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WordRecord::clear_word_index() {
  word_index_ = 0;
  clear_has_word_index();
}
inline ::google::protobuf::int32 WordRecord::word_index() const {
  // @@protoc_insertion_point(field_get:WordRecord.word_index)
  return word_index_;
}
inline void WordRecord::set_word_index(::google::protobuf::int32 value) {
  set_has_word_index();
  word_index_ = value;
  // @@protoc_insertion_point(field_set:WordRecord.word_index)
}

// optional int32 class_index = 3;
inline bool WordRecord::has_class_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WordRecord::set_has_class_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WordRecord::clear_has_class_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WordRecord::clear_class_index() {
  class_index_ = 0;
  clear_has_class_index();
}
inline ::google::protobuf::int32 WordRecord::class_index() const {
  // @@protoc_insertion_point(field_get:WordRecord.class_index)
  return class_index_;
}
inline void WordRecord::set_class_index(::google::protobuf::int32 value) {
  set_has_class_index();
  class_index_ = value;
  // @@protoc_insertion_point(field_set:WordRecord.class_index)
}

// optional int32 class_start = 4;
inline bool WordRecord::has_class_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WordRecord::set_has_class_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WordRecord::clear_has_class_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WordRecord::clear_class_start() {
  class_start_ = 0;
  clear_has_class_start();
}
inline ::google::protobuf::int32 WordRecord::class_start() const {
  // @@protoc_insertion_point(field_get:WordRecord.class_start)
  return class_start_;
}
inline void WordRecord::set_class_start(::google::protobuf::int32 value) {
  set_has_class_start();
  class_start_ = value;
  // @@protoc_insertion_point(field_set:WordRecord.class_start)
}

// optional int32 class_end = 5;
inline bool WordRecord::has_class_end() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WordRecord::set_has_class_end() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WordRecord::clear_has_class_end() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WordRecord::clear_class_end() {
  class_end_ = 0;
  clear_has_class_end();
}
inline ::google::protobuf::int32 WordRecord::class_end() const {
  // @@protoc_insertion_point(field_get:WordRecord.class_end)
  return class_end_;
}
inline void WordRecord::set_class_end(::google::protobuf::int32 value) {
  set_has_class_end();
  class_end_ = value;
  // @@protoc_insertion_point(field_set:WordRecord.class_end)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_lstm_2eproto__INCLUDED
