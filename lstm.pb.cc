// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lstm.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "lstm.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* EmbeddingProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EmbeddingProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* LossProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LossProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* UnrollProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UnrollProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* HiddenProto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HiddenProto_reflection_ = NULL;
const ::google::protobuf::Descriptor* WordRecord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WordRecord_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_lstm_2eproto() {
  protobuf_AddDesc_lstm_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "lstm.proto");
  GOOGLE_CHECK(file != NULL);
  EmbeddingProto_descriptor_ = file->message_type(0);
  static const int EmbeddingProto_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmbeddingProto, word_dim_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmbeddingProto, vocab_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmbeddingProto, batch_size_),
  };
  EmbeddingProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EmbeddingProto_descriptor_,
      EmbeddingProto::default_instance_,
      EmbeddingProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmbeddingProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EmbeddingProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EmbeddingProto));
  LossProto_descriptor_ = file->message_type(1);
  static const int LossProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LossProto, nclass_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LossProto, vocab_size_),
  };
  LossProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LossProto_descriptor_,
      LossProto::default_instance_,
      LossProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LossProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LossProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LossProto));
  DataProto_descriptor_ = file->message_type(2);
  static const int DataProto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataProto, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataProto, max_window_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataProto, backend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataProto, batch_size_),
  };
  DataProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataProto_descriptor_,
      DataProto::default_instance_,
      DataProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataProto));
  UnrollProto_descriptor_ = file->message_type(3);
  static const int UnrollProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnrollProto, batch_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnrollProto, max_window_),
  };
  UnrollProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UnrollProto_descriptor_,
      UnrollProto::default_instance_,
      UnrollProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnrollProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnrollProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UnrollProto));
  HiddenProto_descriptor_ = file->message_type(4);
  static const int HiddenProto_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HiddenProto, word_dim_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HiddenProto, batch_size_),
  };
  HiddenProto_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HiddenProto_descriptor_,
      HiddenProto::default_instance_,
      HiddenProto_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HiddenProto, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HiddenProto, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HiddenProto));
  WordRecord_descriptor_ = file->message_type(5);
  static const int WordRecord_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRecord, word_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRecord, word_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRecord, class_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRecord, class_start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRecord, class_end_),
  };
  WordRecord_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WordRecord_descriptor_,
      WordRecord::default_instance_,
      WordRecord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRecord, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRecord, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WordRecord));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_lstm_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EmbeddingProto_descriptor_, &EmbeddingProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LossProto_descriptor_, &LossProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataProto_descriptor_, &DataProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UnrollProto_descriptor_, &UnrollProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HiddenProto_descriptor_, &HiddenProto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WordRecord_descriptor_, &WordRecord::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_lstm_2eproto() {
  delete EmbeddingProto::default_instance_;
  delete EmbeddingProto_reflection_;
  delete LossProto::default_instance_;
  delete LossProto_reflection_;
  delete DataProto::default_instance_;
  delete DataProto_reflection_;
  delete DataProto::_default_backend_;
  delete UnrollProto::default_instance_;
  delete UnrollProto_reflection_;
  delete HiddenProto::default_instance_;
  delete HiddenProto_reflection_;
  delete WordRecord::default_instance_;
  delete WordRecord_reflection_;
}

void protobuf_AddDesc_lstm_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::singa::protobuf_AddDesc_job_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nlstm.proto\032\tjob.proto\"J\n\016EmbeddingProt"
    "o\022\020\n\010word_dim\030\001 \001(\005\022\022\n\nvocab_size\030\002 \001(\005\022"
    "\022\n\nbatch_size\030\003 \001(\005\"/\n\tLossProto\022\016\n\006ncla"
    "ss\030\001 \001(\005\022\022\n\nvocab_size\030\002 \001(\005\"Z\n\tDataProt"
    "o\022\014\n\004path\030\001 \002(\t\022\022\n\nmax_window\030\002 \001(\005\022\027\n\007b"
    "ackend\030\003 \001(\t:\006kvfile\022\022\n\nbatch_size\030\004 \001(\005"
    "\"5\n\013UnrollProto\022\022\n\nbatch_size\030\001 \001(\005\022\022\n\nm"
    "ax_window\030\002 \001(\005\"3\n\013HiddenProto\022\020\n\010word_d"
    "im\030\001 \001(\005\022\022\n\nbatch_size\030\002 \001(\005\"k\n\nWordReco"
    "rd\022\014\n\004word\030\001 \001(\t\022\022\n\nword_index\030\002 \001(\005\022\023\n\013"
    "class_index\030\003 \001(\005\022\023\n\013class_start\030\004 \001(\005\022\021"
    "\n\tclass_end\030\005 \001(\005::\n\016embedding_conf\022\021.si"
    "nga.LayerProto\030e \001(\0132\017.EmbeddingProto:0\n"
    "\tloss_conf\022\021.singa.LayerProto\030f \001(\0132\n.Lo"
    "ssProto:0\n\tdata_conf\022\021.singa.LayerProto\030"
    "g \001(\0132\n.DataProto:4\n\013unroll_conf\022\021.singa"
    ".LayerProto\030h \001(\0132\014.UnrollProto:1\n\010hid_c"
    "onf\022\021.singa.LayerProto\030i \001(\0132\014.HiddenPro"
    "to", 722);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "lstm.proto", &protobuf_RegisterTypes);
  EmbeddingProto::default_instance_ = new EmbeddingProto();
  LossProto::default_instance_ = new LossProto();
  DataProto::_default_backend_ =
      new ::std::string("kvfile", 6);
  DataProto::default_instance_ = new DataProto();
  UnrollProto::default_instance_ = new UnrollProto();
  HiddenProto::default_instance_ = new HiddenProto();
  WordRecord::default_instance_ = new WordRecord();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::singa::LayerProto::default_instance(),
    101, 11, false, false,
    &::EmbeddingProto::default_instance());
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::singa::LayerProto::default_instance(),
    102, 11, false, false,
    &::LossProto::default_instance());
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::singa::LayerProto::default_instance(),
    103, 11, false, false,
    &::DataProto::default_instance());
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::singa::LayerProto::default_instance(),
    104, 11, false, false,
    &::UnrollProto::default_instance());
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    &::singa::LayerProto::default_instance(),
    105, 11, false, false,
    &::HiddenProto::default_instance());
  EmbeddingProto::default_instance_->InitAsDefaultInstance();
  LossProto::default_instance_->InitAsDefaultInstance();
  DataProto::default_instance_->InitAsDefaultInstance();
  UnrollProto::default_instance_->InitAsDefaultInstance();
  HiddenProto::default_instance_->InitAsDefaultInstance();
  WordRecord::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_lstm_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_lstm_2eproto {
  StaticDescriptorInitializer_lstm_2eproto() {
    protobuf_AddDesc_lstm_2eproto();
  }
} static_descriptor_initializer_lstm_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int EmbeddingProto::kWordDimFieldNumber;
const int EmbeddingProto::kVocabSizeFieldNumber;
const int EmbeddingProto::kBatchSizeFieldNumber;
#endif  // !_MSC_VER

EmbeddingProto::EmbeddingProto()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:EmbeddingProto)
}

void EmbeddingProto::InitAsDefaultInstance() {
}

EmbeddingProto::EmbeddingProto(const EmbeddingProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:EmbeddingProto)
}

void EmbeddingProto::SharedCtor() {
  _cached_size_ = 0;
  word_dim_ = 0;
  vocab_size_ = 0;
  batch_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EmbeddingProto::~EmbeddingProto() {
  // @@protoc_insertion_point(destructor:EmbeddingProto)
  SharedDtor();
}

void EmbeddingProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EmbeddingProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EmbeddingProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EmbeddingProto_descriptor_;
}

const EmbeddingProto& EmbeddingProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_lstm_2eproto();
  return *default_instance_;
}

EmbeddingProto* EmbeddingProto::default_instance_ = NULL;

EmbeddingProto* EmbeddingProto::New() const {
  return new EmbeddingProto;
}

void EmbeddingProto::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<EmbeddingProto*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(word_dim_, batch_size_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EmbeddingProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:EmbeddingProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 word_dim = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &word_dim_)));
          set_has_word_dim();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_vocab_size;
        break;
      }

      // optional int32 vocab_size = 2;
      case 2: {
        if (tag == 16) {
         parse_vocab_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &vocab_size_)));
          set_has_vocab_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_batch_size;
        break;
      }

      // optional int32 batch_size = 3;
      case 3: {
        if (tag == 24) {
         parse_batch_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &batch_size_)));
          set_has_batch_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:EmbeddingProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:EmbeddingProto)
  return false;
#undef DO_
}

void EmbeddingProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:EmbeddingProto)
  // optional int32 word_dim = 1;
  if (has_word_dim()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->word_dim(), output);
  }

  // optional int32 vocab_size = 2;
  if (has_vocab_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->vocab_size(), output);
  }

  // optional int32 batch_size = 3;
  if (has_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->batch_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:EmbeddingProto)
}

::google::protobuf::uint8* EmbeddingProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:EmbeddingProto)
  // optional int32 word_dim = 1;
  if (has_word_dim()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->word_dim(), target);
  }

  // optional int32 vocab_size = 2;
  if (has_vocab_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->vocab_size(), target);
  }

  // optional int32 batch_size = 3;
  if (has_batch_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->batch_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:EmbeddingProto)
  return target;
}

int EmbeddingProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 word_dim = 1;
    if (has_word_dim()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->word_dim());
    }

    // optional int32 vocab_size = 2;
    if (has_vocab_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->vocab_size());
    }

    // optional int32 batch_size = 3;
    if (has_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->batch_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EmbeddingProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EmbeddingProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EmbeddingProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EmbeddingProto::MergeFrom(const EmbeddingProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_word_dim()) {
      set_word_dim(from.word_dim());
    }
    if (from.has_vocab_size()) {
      set_vocab_size(from.vocab_size());
    }
    if (from.has_batch_size()) {
      set_batch_size(from.batch_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EmbeddingProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EmbeddingProto::CopyFrom(const EmbeddingProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EmbeddingProto::IsInitialized() const {

  return true;
}

void EmbeddingProto::Swap(EmbeddingProto* other) {
  if (other != this) {
    std::swap(word_dim_, other->word_dim_);
    std::swap(vocab_size_, other->vocab_size_);
    std::swap(batch_size_, other->batch_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EmbeddingProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EmbeddingProto_descriptor_;
  metadata.reflection = EmbeddingProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LossProto::kNclassFieldNumber;
const int LossProto::kVocabSizeFieldNumber;
#endif  // !_MSC_VER

LossProto::LossProto()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:LossProto)
}

void LossProto::InitAsDefaultInstance() {
}

LossProto::LossProto(const LossProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:LossProto)
}

void LossProto::SharedCtor() {
  _cached_size_ = 0;
  nclass_ = 0;
  vocab_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LossProto::~LossProto() {
  // @@protoc_insertion_point(destructor:LossProto)
  SharedDtor();
}

void LossProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LossProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LossProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LossProto_descriptor_;
}

const LossProto& LossProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_lstm_2eproto();
  return *default_instance_;
}

LossProto* LossProto::default_instance_ = NULL;

LossProto* LossProto::New() const {
  return new LossProto;
}

void LossProto::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LossProto*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(nclass_, vocab_size_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LossProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:LossProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 nclass = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nclass_)));
          set_has_nclass();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_vocab_size;
        break;
      }

      // optional int32 vocab_size = 2;
      case 2: {
        if (tag == 16) {
         parse_vocab_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &vocab_size_)));
          set_has_vocab_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:LossProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:LossProto)
  return false;
#undef DO_
}

void LossProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:LossProto)
  // optional int32 nclass = 1;
  if (has_nclass()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->nclass(), output);
  }

  // optional int32 vocab_size = 2;
  if (has_vocab_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->vocab_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:LossProto)
}

::google::protobuf::uint8* LossProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:LossProto)
  // optional int32 nclass = 1;
  if (has_nclass()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->nclass(), target);
  }

  // optional int32 vocab_size = 2;
  if (has_vocab_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->vocab_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LossProto)
  return target;
}

int LossProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 nclass = 1;
    if (has_nclass()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nclass());
    }

    // optional int32 vocab_size = 2;
    if (has_vocab_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->vocab_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LossProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LossProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LossProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LossProto::MergeFrom(const LossProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nclass()) {
      set_nclass(from.nclass());
    }
    if (from.has_vocab_size()) {
      set_vocab_size(from.vocab_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LossProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LossProto::CopyFrom(const LossProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LossProto::IsInitialized() const {

  return true;
}

void LossProto::Swap(LossProto* other) {
  if (other != this) {
    std::swap(nclass_, other->nclass_);
    std::swap(vocab_size_, other->vocab_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LossProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LossProto_descriptor_;
  metadata.reflection = LossProto_reflection_;
  return metadata;
}


// ===================================================================

::std::string* DataProto::_default_backend_ = NULL;
#ifndef _MSC_VER
const int DataProto::kPathFieldNumber;
const int DataProto::kMaxWindowFieldNumber;
const int DataProto::kBackendFieldNumber;
const int DataProto::kBatchSizeFieldNumber;
#endif  // !_MSC_VER

DataProto::DataProto()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:DataProto)
}

void DataProto::InitAsDefaultInstance() {
}

DataProto::DataProto(const DataProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:DataProto)
}

void DataProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  max_window_ = 0;
  backend_ = const_cast< ::std::string*>(_default_backend_);
  batch_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataProto::~DataProto() {
  // @@protoc_insertion_point(destructor:DataProto)
  SharedDtor();
}

void DataProto::SharedDtor() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (backend_ != _default_backend_) {
    delete backend_;
  }
  if (this != default_instance_) {
  }
}

void DataProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DataProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataProto_descriptor_;
}

const DataProto& DataProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_lstm_2eproto();
  return *default_instance_;
}

DataProto* DataProto::default_instance_ = NULL;

DataProto* DataProto::New() const {
  return new DataProto;
}

void DataProto::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DataProto*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(max_window_, batch_size_);
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        path_->clear();
      }
    }
    if (has_backend()) {
      if (backend_ != _default_backend_) {
        backend_->assign(*_default_backend_);
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:DataProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_window;
        break;
      }

      // optional int32 max_window = 2;
      case 2: {
        if (tag == 16) {
         parse_max_window:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_window_)));
          set_has_max_window();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_backend;
        break;
      }

      // optional string backend = 3 [default = "kvfile"];
      case 3: {
        if (tag == 26) {
         parse_backend:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_backend()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->backend().data(), this->backend().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "backend");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_batch_size;
        break;
      }

      // optional int32 batch_size = 4;
      case 4: {
        if (tag == 32) {
         parse_batch_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &batch_size_)));
          set_has_batch_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:DataProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:DataProto)
  return false;
#undef DO_
}

void DataProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:DataProto)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->path(), output);
  }

  // optional int32 max_window = 2;
  if (has_max_window()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_window(), output);
  }

  // optional string backend = 3 [default = "kvfile"];
  if (has_backend()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->backend().data(), this->backend().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "backend");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->backend(), output);
  }

  // optional int32 batch_size = 4;
  if (has_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->batch_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:DataProto)
}

::google::protobuf::uint8* DataProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:DataProto)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->path(), target);
  }

  // optional int32 max_window = 2;
  if (has_max_window()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->max_window(), target);
  }

  // optional string backend = 3 [default = "kvfile"];
  if (has_backend()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->backend().data(), this->backend().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "backend");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->backend(), target);
  }

  // optional int32 batch_size = 4;
  if (has_batch_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->batch_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DataProto)
  return target;
}

int DataProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string path = 1;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

    // optional int32 max_window = 2;
    if (has_max_window()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_window());
    }

    // optional string backend = 3 [default = "kvfile"];
    if (has_backend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->backend());
    }

    // optional int32 batch_size = 4;
    if (has_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->batch_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataProto::MergeFrom(const DataProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_max_window()) {
      set_max_window(from.max_window());
    }
    if (from.has_backend()) {
      set_backend(from.backend());
    }
    if (from.has_batch_size()) {
      set_batch_size(from.batch_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataProto::CopyFrom(const DataProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DataProto::Swap(DataProto* other) {
  if (other != this) {
    std::swap(path_, other->path_);
    std::swap(max_window_, other->max_window_);
    std::swap(backend_, other->backend_);
    std::swap(batch_size_, other->batch_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DataProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DataProto_descriptor_;
  metadata.reflection = DataProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UnrollProto::kBatchSizeFieldNumber;
const int UnrollProto::kMaxWindowFieldNumber;
#endif  // !_MSC_VER

UnrollProto::UnrollProto()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:UnrollProto)
}

void UnrollProto::InitAsDefaultInstance() {
}

UnrollProto::UnrollProto(const UnrollProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:UnrollProto)
}

void UnrollProto::SharedCtor() {
  _cached_size_ = 0;
  batch_size_ = 0;
  max_window_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnrollProto::~UnrollProto() {
  // @@protoc_insertion_point(destructor:UnrollProto)
  SharedDtor();
}

void UnrollProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UnrollProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnrollProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UnrollProto_descriptor_;
}

const UnrollProto& UnrollProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_lstm_2eproto();
  return *default_instance_;
}

UnrollProto* UnrollProto::default_instance_ = NULL;

UnrollProto* UnrollProto::New() const {
  return new UnrollProto;
}

void UnrollProto::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UnrollProto*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(batch_size_, max_window_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UnrollProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:UnrollProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 batch_size = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &batch_size_)));
          set_has_batch_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_window;
        break;
      }

      // optional int32 max_window = 2;
      case 2: {
        if (tag == 16) {
         parse_max_window:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_window_)));
          set_has_max_window();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:UnrollProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:UnrollProto)
  return false;
#undef DO_
}

void UnrollProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:UnrollProto)
  // optional int32 batch_size = 1;
  if (has_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->batch_size(), output);
  }

  // optional int32 max_window = 2;
  if (has_max_window()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_window(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:UnrollProto)
}

::google::protobuf::uint8* UnrollProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:UnrollProto)
  // optional int32 batch_size = 1;
  if (has_batch_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->batch_size(), target);
  }

  // optional int32 max_window = 2;
  if (has_max_window()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->max_window(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UnrollProto)
  return target;
}

int UnrollProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 batch_size = 1;
    if (has_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->batch_size());
    }

    // optional int32 max_window = 2;
    if (has_max_window()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_window());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnrollProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UnrollProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UnrollProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UnrollProto::MergeFrom(const UnrollProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_batch_size()) {
      set_batch_size(from.batch_size());
    }
    if (from.has_max_window()) {
      set_max_window(from.max_window());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UnrollProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnrollProto::CopyFrom(const UnrollProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnrollProto::IsInitialized() const {

  return true;
}

void UnrollProto::Swap(UnrollProto* other) {
  if (other != this) {
    std::swap(batch_size_, other->batch_size_);
    std::swap(max_window_, other->max_window_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UnrollProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UnrollProto_descriptor_;
  metadata.reflection = UnrollProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HiddenProto::kWordDimFieldNumber;
const int HiddenProto::kBatchSizeFieldNumber;
#endif  // !_MSC_VER

HiddenProto::HiddenProto()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:HiddenProto)
}

void HiddenProto::InitAsDefaultInstance() {
}

HiddenProto::HiddenProto(const HiddenProto& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HiddenProto)
}

void HiddenProto::SharedCtor() {
  _cached_size_ = 0;
  word_dim_ = 0;
  batch_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HiddenProto::~HiddenProto() {
  // @@protoc_insertion_point(destructor:HiddenProto)
  SharedDtor();
}

void HiddenProto::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HiddenProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HiddenProto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HiddenProto_descriptor_;
}

const HiddenProto& HiddenProto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_lstm_2eproto();
  return *default_instance_;
}

HiddenProto* HiddenProto::default_instance_ = NULL;

HiddenProto* HiddenProto::New() const {
  return new HiddenProto;
}

void HiddenProto::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<HiddenProto*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(word_dim_, batch_size_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HiddenProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:HiddenProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 word_dim = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &word_dim_)));
          set_has_word_dim();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_batch_size;
        break;
      }

      // optional int32 batch_size = 2;
      case 2: {
        if (tag == 16) {
         parse_batch_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &batch_size_)));
          set_has_batch_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:HiddenProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HiddenProto)
  return false;
#undef DO_
}

void HiddenProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HiddenProto)
  // optional int32 word_dim = 1;
  if (has_word_dim()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->word_dim(), output);
  }

  // optional int32 batch_size = 2;
  if (has_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->batch_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:HiddenProto)
}

::google::protobuf::uint8* HiddenProto::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:HiddenProto)
  // optional int32 word_dim = 1;
  if (has_word_dim()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->word_dim(), target);
  }

  // optional int32 batch_size = 2;
  if (has_batch_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->batch_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HiddenProto)
  return target;
}

int HiddenProto::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 word_dim = 1;
    if (has_word_dim()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->word_dim());
    }

    // optional int32 batch_size = 2;
    if (has_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->batch_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HiddenProto::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HiddenProto* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HiddenProto*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HiddenProto::MergeFrom(const HiddenProto& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_word_dim()) {
      set_word_dim(from.word_dim());
    }
    if (from.has_batch_size()) {
      set_batch_size(from.batch_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HiddenProto::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HiddenProto::CopyFrom(const HiddenProto& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HiddenProto::IsInitialized() const {

  return true;
}

void HiddenProto::Swap(HiddenProto* other) {
  if (other != this) {
    std::swap(word_dim_, other->word_dim_);
    std::swap(batch_size_, other->batch_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HiddenProto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HiddenProto_descriptor_;
  metadata.reflection = HiddenProto_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WordRecord::kWordFieldNumber;
const int WordRecord::kWordIndexFieldNumber;
const int WordRecord::kClassIndexFieldNumber;
const int WordRecord::kClassStartFieldNumber;
const int WordRecord::kClassEndFieldNumber;
#endif  // !_MSC_VER

WordRecord::WordRecord()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:WordRecord)
}

void WordRecord::InitAsDefaultInstance() {
}

WordRecord::WordRecord(const WordRecord& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:WordRecord)
}

void WordRecord::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  word_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  word_index_ = 0;
  class_index_ = 0;
  class_start_ = 0;
  class_end_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WordRecord::~WordRecord() {
  // @@protoc_insertion_point(destructor:WordRecord)
  SharedDtor();
}

void WordRecord::SharedDtor() {
  if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete word_;
  }
  if (this != default_instance_) {
  }
}

void WordRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WordRecord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WordRecord_descriptor_;
}

const WordRecord& WordRecord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_lstm_2eproto();
  return *default_instance_;
}

WordRecord* WordRecord::default_instance_ = NULL;

WordRecord* WordRecord::New() const {
  return new WordRecord;
}

void WordRecord::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<WordRecord*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(word_index_, class_end_);
    if (has_word()) {
      if (word_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        word_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WordRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:WordRecord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string word = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->word().data(), this->word().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "word");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_word_index;
        break;
      }

      // optional int32 word_index = 2;
      case 2: {
        if (tag == 16) {
         parse_word_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &word_index_)));
          set_has_word_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_class_index;
        break;
      }

      // optional int32 class_index = 3;
      case 3: {
        if (tag == 24) {
         parse_class_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &class_index_)));
          set_has_class_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_class_start;
        break;
      }

      // optional int32 class_start = 4;
      case 4: {
        if (tag == 32) {
         parse_class_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &class_start_)));
          set_has_class_start();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_class_end;
        break;
      }

      // optional int32 class_end = 5;
      case 5: {
        if (tag == 40) {
         parse_class_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &class_end_)));
          set_has_class_end();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:WordRecord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:WordRecord)
  return false;
#undef DO_
}

void WordRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:WordRecord)
  // optional string word = 1;
  if (has_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "word");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->word(), output);
  }

  // optional int32 word_index = 2;
  if (has_word_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->word_index(), output);
  }

  // optional int32 class_index = 3;
  if (has_class_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->class_index(), output);
  }

  // optional int32 class_start = 4;
  if (has_class_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->class_start(), output);
  }

  // optional int32 class_end = 5;
  if (has_class_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->class_end(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:WordRecord)
}

::google::protobuf::uint8* WordRecord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:WordRecord)
  // optional string word = 1;
  if (has_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "word");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->word(), target);
  }

  // optional int32 word_index = 2;
  if (has_word_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->word_index(), target);
  }

  // optional int32 class_index = 3;
  if (has_class_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->class_index(), target);
  }

  // optional int32 class_start = 4;
  if (has_class_start()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->class_start(), target);
  }

  // optional int32 class_end = 5;
  if (has_class_end()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->class_end(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:WordRecord)
  return target;
}

int WordRecord::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string word = 1;
    if (has_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->word());
    }

    // optional int32 word_index = 2;
    if (has_word_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->word_index());
    }

    // optional int32 class_index = 3;
    if (has_class_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->class_index());
    }

    // optional int32 class_start = 4;
    if (has_class_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->class_start());
    }

    // optional int32 class_end = 5;
    if (has_class_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->class_end());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WordRecord::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WordRecord* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WordRecord*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WordRecord::MergeFrom(const WordRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_word()) {
      set_word(from.word());
    }
    if (from.has_word_index()) {
      set_word_index(from.word_index());
    }
    if (from.has_class_index()) {
      set_class_index(from.class_index());
    }
    if (from.has_class_start()) {
      set_class_start(from.class_start());
    }
    if (from.has_class_end()) {
      set_class_end(from.class_end());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WordRecord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WordRecord::CopyFrom(const WordRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordRecord::IsInitialized() const {

  return true;
}

void WordRecord::Swap(WordRecord* other) {
  if (other != this) {
    std::swap(word_, other->word_);
    std::swap(word_index_, other->word_index_);
    std::swap(class_index_, other->class_index_);
    std::swap(class_start_, other->class_start_);
    std::swap(class_end_, other->class_end_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WordRecord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WordRecord_descriptor_;
  metadata.reflection = WordRecord_reflection_;
  return metadata;
}

::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::EmbeddingProto >, 11, false >
  embedding_conf(kEmbeddingConfFieldNumber, ::EmbeddingProto::default_instance());
::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::LossProto >, 11, false >
  loss_conf(kLossConfFieldNumber, ::LossProto::default_instance());
::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::DataProto >, 11, false >
  data_conf(kDataConfFieldNumber, ::DataProto::default_instance());
::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::UnrollProto >, 11, false >
  unroll_conf(kUnrollConfFieldNumber, ::UnrollProto::default_instance());
::google::protobuf::internal::ExtensionIdentifier< ::singa::LayerProto,
    ::google::protobuf::internal::MessageTypeTraits< ::HiddenProto >, 11, false >
  hid_conf(kHidConfFieldNumber, ::HiddenProto::default_instance());

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
